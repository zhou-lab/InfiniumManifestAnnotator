# -*- coding: utf-8 -*-
# !/usr/bin/env python3
import os, sys
import pandas as pd
import argparse
desired_width = 320
pd.set_option('display.width', desired_width)
pd.set_option('display.max_columns', 15)
import numpy as np
import pysam

def prepare_optparser():
    usage = f"python {sys.argv[0]} vcf manifest outdir \
    Manifest file should contain columns of chr, start, end, M,U,target, col,Probe_ID, mapFlag,mask \
    it can be generated by: \
    zcat MM285.mm10.manifest.tsv.gz | sed '1d' | cut -f 1-6,8-9,11,31 > test/manifest.bed\
    For vcf file, there must be one line starts with #CHROM\
    "
    description = "generate strain-specific manifest for SeSAMe" # %prog
    epilog = f"example usage:\n {sys.argv[0]} -vcf mgp.v5.merged.snps_all.dbSNP142.vcf.gz \
    -mft MM285.mm10.manifest.bed -ref /mnt/isilon/zhou_lab/projects/20191221_references/mm10/mm10.fa\
    -o test_dir"
    parser = argparse.ArgumentParser(prog='strain_specific_manifest', usage=usage, \
                                     description=description, epilog=epilog)
    parser.add_argument('-v', '--version', action='version', version='1.0', help='Display version')
    parser.add_argument('-vcf', '--vcf', dest='vcf', type=str, help="input vcf", \
                        metavar="<file>", required=True)
    parser.add_argument('-mft', '--mft', dest='mft', type=str,
                        help="input manifest, a bed file contains columns of chr, start, end, target, Probe_ID, mapFlag",
                        metavar="<file>", required=True)
    parser.add_argument('-ref', '--Reference', dest='Reference', type=str,
                        help="reference genome, .fa",
                        metavar="<file>", required=True)
    parser.add_argument('-o', '--outdir', dest='outdir', default='test', type=str, help="output directory", \
                 metavar="<outdir>", required=True)
    return parser
# =============================================================================
def opt_validate(optparser):
    args = optparser.parse_args()
    print(args)
    args.vcf = os.path.abspath(args.vcf)
    args.mft = os.path.abspath(args.mft)
    args.Reference = os.path.abspath(args.Reference)
    args.outdir = os.path.abspath(args.outdir)
    return args

# vcf=sys.argv[1]
# manifest=os.path.abspath(sys.argv[2])
# Reference=os.path.abspath(sys.argv[3])
# outdir=os.path.abspath(sys.argv[4])

# vcf="mgp.v5.merged.snps_all.dbSNP142.vcf.gz"
# manifest="../../data/strainSpecificManifest/test/MM285.mm10.manifest.bed"
# Reference = os.path.abspath("/mnt/isilon/zhou_lab/projects/20191221_references/mm10/mm10.fa")
# outdir="Demo"

def get_vcf_chr_names(vcf):
    if vcf.endswith('.gz'):
        cmd='zcat '+ vcf + " |grep -v '^#' | cut -f 1|uniq > %s/chr1.bed"%outdir
    else:
        cmd="grep -v '^#' " + vcf + " | cut -f 1|uniq > %s/chr1.bed"%outdir
    if not os.path.exists("%s/chr1.bed"%outdir):
        print("Getting chr names from vcf..")
        os.system(cmd)
    with open("%s/chr1.bed"%outdir) as f:
        chrs=f.read().split('\n')
    return list(set([c for c in chrs if c!='']))

def check_chr_name():
    global vcf_has_chr, vcf_MT,mft_has_chr,mft_MT
    print("Checking whether the chromosome names in manifest match the chr names in vcf")
    chr1=get_vcf_chr_names(vcf)
    chr2 = pd.read_csv(manifest, sep='\t', header=None, usecols=[0]).iloc[:, 0].dropna().unique().tolist()
    chr_set1=list(set([c[:3] for c in chr1 if len(c)>=3]))
    chr_set2 = list(set([c[:3] for c in chr2 if len(c) >= 3]))
    if len(chr_set1)==1 and chr_set1[0]=='chr':
        vcf_has_chr=True
    if len(chr_set2)==1 and chr_set2[0]=='chr':
        mft_has_chr=True
    if 'chrMT' in chr1 or 'MT' in chr1:
        vcf_MT=True
    if 'chrMT' in chr2 or 'MT' in chr2:
        mft_MT=True

    check=True #whether the chr name in vcf and chr in manifest are consistent
    for c in chr1:
        if c not in chr2:
            check=False
    return check

def replace_chr_name():
    check_chr_name()
    mft = pd.read_csv(manifest, header=None, sep='\t',
                      names=['chr','start','end','M','U','target','col','Probe_ID','mapFlag','mask'])
    #chr, start, end, M,U,target, col,Probe_ID, mapFlag,mask
    mft=mft.loc[mft['chr'].notna()]
    if vcf_has_chr:
        if not mft_has_chr:
            mft['chr']='chr'+mft['chr']
        if vcf_MT and not mft_MT:
            mft['chr'].replace({'chrM':'chrMT'},inplace=True)
        if not vcf_MT and mft_MT:
            mft['chr'].replace({'chrMT': 'chrM'}, inplace=True)
    else: #vcf not chr
        if mft_has_chr:
            mft['chr']=mft['chr'].apply(lambda x:x.replace('chr',''))
        if vcf_MT and not mft_MT:
            mft['chr'].replace({'M': 'MT'}, inplace=True)
        if not vcf_MT and mft_MT:
            mft['chr'].replace({'MT': 'M'}, inplace=True)
    mft.drop(['M','U','col','mask'],axis=1,inplace=True)
    mft.to_csv(os.path.join(outdir, "manifest.checked.bed"), sep='\t', index=False,header=False)
    return os.path.join(outdir, "manifest.checked.bed")

def run_bedtools(mft_file,vcf):
    overlapped_output = os.path.join(outdir, "manifest.var.overlapped.bed")
    if os.path.exists(overlapped_output):
        print("The result %s already existed, Skip running bedtools to find the overlap."%overlapped_output)
        return True
    # mft = pd.read_csv(mft_file, header=None, sep='\t',names=['chr', 'start', 'end', 'target', 'Probe_ID', 'mapFlag'])
    cmd="""awk '$4=="CG" && $6!=4' %s | awk 'BEGIN{OFS="\\t"};{if($6==16) {print($1,$2-1,$2+5,$4,$5,$6)} else {print($1,$3-5,$3+1,$4,$5,$6)}}' | bedtools sort -i stdin -chrThenSizeA  > %s/manifest.6bp.bed
    """%(mft_file,outdir)
    os.system(cmd)
    input_mft=os.path.join(outdir,"manifest.6bp.sorted.bed")
    cmd="bedtools sort -i %s -faidx %s > %s"%(os.path.join(outdir,"manifest.6bp.bed"),
                                              os.path.join(outdir,"chr1.bed"),
                                              input_mft)
    os.system(cmd)
    cmd=f"bedtools intersect -a {input_mft} -b {vcf} -wa -wb -sorted > {overlapped_output}"
    print("Running bedtools to calculate the overlap between vcf and manifest, it may take a while..")
    os.system(cmd)

def filter_var(vcf):
    import gzip
    if vcf.endswith('.gz'):
        with open(vcf,'rb') as f:
            fg=gzip.GzipFile(mode='rb',fileobj=f)
            while 1:
                line = fg.readline()
                line=line.decode('utf-8')
                if line.startswith('#CHROM'):
                    cols=line.strip().split('\t')
                    break
            fg.close()
    else:
        with open(vcf,'r') as f:
            while 1:
                line = f.readline()
                if line.startswith('#CHROM'):
                    cols=line.strip().split('\t')
                    break

    df=pd.read_csv(os.path.join(outdir,"manifest.var.overlapped.bed"),header=None,sep='\t',
                   names=['chr', 'start', 'end', 'target', 'Probe_ID', 'mapFlag']+cols)
    cols=df.columns.tolist()
    df=df.set_index(cols[:15]).stack().reset_index()
    df.columns=cols[:15]+['Strain','Value']

    df=df.loc[df.FILTER=='PASS']
    cols=df.columns.tolist()
    df.drop(['FILTER','INFO','FORMAT'],axis=1,inplace=True)

    def processValue(s):
        formats="GT:GQ:DP:MQ0F:GP:PL:AN:MQ:DV:DP4:SP:SGB:PV4:FI".split(':')
        values=s.split(':')
        D={}
        for k,v in zip(formats,values):
            D[k]=v
        if D['GQ']=='.':
            D['GQ']=0
        if D['DP']=='.':
            D['DP']=0
        return D

    df.Value=df.Value.apply(processValue)
    # df.Value.apply(lambda x:x['GT']).unique()
    # Out[114]: array(['./.', '1/1', '0/0', '2/2', '3/3', '4/4', '5/5'], dtype=object)
    df=df.loc[~(df.Value.apply(lambda x:x['GT']).isin(['./.','0/0']))] #remove GT in [./.,0/0], no variants (/SNP)
    df=df.loc[df.Value.apply(lambda x:x['GQ']).map(int) > 20]
    df=df.loc[df.Value.apply(lambda x:x['DP']).map(int) > 8]
    # some ALT has multiple values, separated by ','
    df.ALT=df.loc[:,['ALT','Value']].apply(lambda x:x[0] if ',' not in x[0] else x[0].split(',')[int(x[1]['GT'].split('/')[0])-1],axis=1)

    #Filtering out the variants located at the 6th base of type II probe's 3 end
    # exclude +2 bp, beg is 0-based, converted to 1-based
    excluded_idx1=df.loc[df.Probe_ID.apply(lambda x:x[-2]=='2')].query("(mapFlag==0 & POS==end) | (mapFlag==16 & POS==start+1)").index.tolist()
    #Exclude the +2 bp for type I opposited probes
    excluded_idx2 = df.loc[df.Probe_ID.apply(lambda x: x[-2] == '1' and x[-3]=='O')].query(
        "(mapFlag==0 & POS==end) | (mapFlag==16 & POS==start+1)").index.tolist()
    excluded_idx=list(set(excluded_idx1+excluded_idx2))
    df=df.loc[~ df.index.to_series().isin(excluded_idx)]
    df.to_csv(os.path.join(outdir,"manifest.var.overlapped.filtered.txt"),sep='\t',index=False)

def annotate_var():
    global vcf_has_chr, vcf_MT, mft_has_chr, mft_MT
    df=pd.read_csv(os.path.join(outdir,"manifest.var.overlapped.filtered.txt"),sep='\t')
    cols=df.columns.tolist()
    df.Value=1
    df=df.pivot(index=cols[:12],columns='Strain',values='Value').reset_index()
    strains=df.columns.tolist()[12:]
    for strain in strains:
        df[strain].fillna(0,inplace=True)
    #df.iloc[:,0:12]
    def getTargetCpGPos(s):
        """
        Find the position of C (of CpG)
        :param s: beg and end are the start and end of the last 6 bp of probe's 3' end, including the extension base
        :return:
        """
        t=s.Probe_ID[-2]
        if s.mapFlag==0: #Forward strand, CpG locates at the end of seq
            return s.end-2 #s.end-1 #-based, excluding the last extension base
        else: # Reverse strand
            return s.start+2 #beg is 0-based, converted to 1-based and exclude the first extension base.

    df['TargetCpGPos']=df.apply(lambda x:getTargetCpGPos(x),axis=1)
    print("Checking whether the chromosome names in manifest match the chr names in reference genome")
    fa=pysam.FastaFile(Reference)
    ref_chrs=fa.references
    ref_chr_set = list(set([c[:3] for c in ref_chrs if len(c) >= 3]))
    ref_has_chr=False
    ref_MT=False
    if len(ref_chr_set) == 1 and ref_chr_set[0] == 'chr':
        ref_has_chr = True
    if 'chrMT' in ref_chrs or 'MT' in ref_chrs:
        ref_MT=True
    if ref_has_chr:
        if not vcf_has_chr:
            df['chr'] = df['chr'].apply(lambda x: 'chr' + str(x))
        if ref_MT and not vcf_MT:
            df['chr'].replace({'chrM':'chrMT'},inplace=True)
        if not ref_MT and vcf_MT:
            df['chr'].replace({'chrMT': 'chrM'}, inplace=True)
    else: # ref does not have chr
        if vcf_has_chr:
            df['chr'] = df['chr'].apply(lambda x: x.replace('chr', ''))
        if ref_MT and not vcf_MT:
            df['chr'].replace({'M': 'MT'}, inplace=True)
        if not ref_MT and vcf_MT:
            df['chr'].replace({'MT': 'M'}, inplace=True)

    df['cg']=df.loc[:,['chr','TargetCpGPos']].apply(lambda x:fa.fetch(reference=x[0],start=x[1]-1,end=x[1]+1),axis=1)
    unique_cg=df.cg.apply(lambda x:x.upper()).unique()
    if not (len(unique_cg)==1 and unique_cg[0]=='CG'):
        print("Wainning: not all Target CpGs are CG, Please check the position and chr")
    df.drop('cg',axis=1,inplace=True)
    #REF_3kmer is the 3-kmer for the variant.
    df['REF_3kmer']=df.loc[:,['chr','POS']].apply(lambda x:fa.fetch(reference=x[0],start=x[1]-2,end=x[1]+1),axis=1)
    #CpGContext is 4-kmer sequence of the CpG site.
    df['CpGContext']=df.loc[:,['chr','TargetCpGPos']].apply(lambda x:fa.fetch(reference=x[0],start=x[1]-2,end=x[1]+2),axis=1)
    fa.close()

    # df.iloc[:,np.r_[0:14,-2,-1]]
    #samtools faidx  ~/references/mm10/mm10.fa chrMT:2899-2904
    df['Target']=(df.POS-df.TargetCpGPos).isin([0,1]).map(int)
    df['CpG']=df.REF_3kmer.apply(lambda x:'cg' in x.lower()).map(int)
    df['ProbeDesign']=df.Probe_ID.apply(lambda x:'I' if x[-2]=='1' else 'II' if x[-2]=='2' else np.nan)
    df['CON']=df.Probe_ID.apply(lambda x:x[-3])
    def IsExtBase(s):
        if s.ProbeDesign=='I' and s.CON=='C': #POS is the position of SNP ALT, 1-based, target CpG is 1-based too.
            if s.POS==s.TargetCpGPos+2 and s.mapFlag==0:
                return 1
            elif s.POS+1==s.TargetCpGPos and s.mapFlag==16:
                return 1
            else:
                return 0
        elif s.ProbeDesign=='I' and s.CON=='O': # type I probes Opposited
            if s.mapFlag==0 and s.POS==s.TargetCpGPos+1:
                return 1
            elif s.mapFlag==16 and s.POS==s.TargetCpGPos:
                return 1
            else:
                return 0
        else:# for type II, extension base is always G or C.
            return 0

    df['ExtensionBase']=df.apply(lambda x:IsExtBase(x),axis=1)
    df['Context1']=df.REF_3kmer.apply(lambda x:x[:2])
    df['Context2']=df.REF_3kmer.apply(lambda x:x[1:])
    df['RefAlt']=df.REF+df.ALT
    type_cols=['Target','CpG','ExtensionBase','Context1','Context2','ProbeDesign','CON','mapFlag','RefAlt','chr','POS']
    df['Type']=df.loc[:,type_cols].apply(lambda x:'-'.join([str(i) for i in x]),axis=1)
    D={'A':'T','C':'G','T':'A','G':'C'}
    def getNextBase(s):#flag,context,probeType,probe
        """
        Next base paired with the reference genome
        R=A,G
        Y=C,T,U
        H=A,C,T
        D=A,G,T
        :param s:
        :return:
        """
        if s.ProbeDesign=='II':
            if s.CON=='C': #G
                return 'R' #
            else: #C
                return 'Y'
        else:
            if s.mapFlag==16 and s.CON=='C':
                return D[s.CpGContext[0].upper()]
            elif s.mapFlag==16 and s.CON=='O': #equal to forward, Converted
                return 'G'
            elif s.mapFlag==0 and s.CON=='C':
                return s.CpGContext[-1].upper()
            else:
                return 'G'

    df['NextBase']=df.apply(lambda x:getNextBase(x),axis=1)
    df.to_csv(os.path.join(outdir,"manifest.var.overlapped.annotated.txt"),sep='\t',index=False)

def assignType(s):
    if s.Target=='1':
        if s.Context2=='CG' and s.RefAlt=='CT':
            if s.mapFlag=='16' and s.CON=='C':
                return 1
            elif s.ProbeDesign=='II' and s.CON=='O':
                return 2
            else:
                return 45
        elif s.Context1=='CG' and s.RefAlt=='GA':
            if s.mapFlag=='0' and s.CON=='C':
                return 3
            elif s.ProbeDesign=='II' and s.CON=='O':
                return 4
            else:
                return 45
        elif s.Context2=='CG' and s.RefAlt=='CG':
            if s.ProbeDesign=='II' and s.mapFlag=='16' and s.CON=='C':
                return 5
            elif s.ProbeDesign=='II' and s.mapFlag=='16' and s.CON=='O':
                return 6
            elif s.ProbeDesign=='II' and s.mapFlag=='0' and s.CON=='O':
                return 7
            else:
                return 45
        elif s.Context1=='CG' and s.RefAlt=='GC':
            if s.ProbeDesign=='II' and s.mapFlag=='0' and s.CON=='C':
                return 8
            elif s.ProbeDesign=='II' and s.mapFlag=='0' and s.CON=='O':
                return 9
            elif s.ProbeDesign=='II' and s.mapFlag=='16' and s.CON=='O':
                return 10
            else:
                return 45
        elif s.Context2=='CG' and s.RefAlt=='CA':
            if s.ProbeDesign=='II' and s.mapFlag=='16' and s.CON=='C': #CG -> AG
                return 11
            elif s.ProbeDesign=='II' and s.CON=='O':
                return 12
            else:
                return 45
        elif s.Context1=='CG' and s.RefAlt=='GT':
            if s.ProbeDesign=='II' and s.mapFlag=='0' and s.CON=='C': #CG -> CT
                return 13
            elif s.ProbeDesign=='II' and s.CON=='O':
                return 14
            else:
                return 45
        else:
            return 45
    elif s.Target=='0' and s.ExtensionBase=='0':
        if s.Context2[0]=='C' and s.RefAlt=='CT': #CH -> TH
            if s.mapFlag=='0' and s.CON=='O':
                return 15
            elif s.mapFlag=='16' and s.CON=='C':
                return 16
            else:
                return 45
        elif s.Context2[0]=='T' and s.RefAlt=='TC': #T* -> C*
            if s.mapFlag=='0' and s.CON=='O':
                return 17
            elif s.mapFlag=='16' and s.CON=='C':
                return 18
            else:
                return 45
        elif s.Context1[1]=='G' and s.RefAlt=='GA': #DG -> DA
            if s.mapFlag=='0' and s.CON=='C':
                return 19
            elif s.mapFlag=='16' and s.CON=='O':
                return 20
            else:
                return 45
        elif s.Context1[1]=='A' and s.RefAlt=='AG': #*A -> *G
            if s.mapFlag=='0' and s.CON=='C':
                return 21
            elif s.mapFlag=='16' and s.CON=='O':
                return 22
            else:
                return 45
        else:
            return 45
    elif s.Target=='0' and s.ProbeDesign=='I' and s.ExtensionBase=='1':
        i=25
        ExtDict={}
        for ref_alt in ['AC','AG','CA','CT','CG','TC','TG','GA','GC','GT']:
            for strand in ['0','16']:
                ExtDict[tuple([ref_alt,strand,'C'])]=i
                i+=1
        if s.RefAlt=='AT':
            return 23
        elif s.RefAlt=='TA':
            return 24
        elif tuple([s.RefAlt,s.mapFlag,s.CON]) in ExtDict:
            return ExtDict[tuple([s.RefAlt,s.mapFlag,s.CON])]
        else:
            return 45
    else:
        return 45

def assignGroup(s):
    if s.SNPType in [1,2,3,4,6,9,11,12,13,14]:
        return 'G1'
    elif s.SNPType in [5,7,8,10]:
        return 'G3'
    elif s.SNPType == 45:
        return 'G2'
    elif s.SNPType in [29,31,33,40,42,44]:
        return 'G4'
    elif s.SNPType in [25,28,34,35,38,41]:
        return 'G5'
    else:
        return 'G0'

def generateStrainSpecificVariants():
    df=pd.read_csv(os.path.join(outdir,"manifest.var.overlapped.annotated.txt"),sep='\t')
    cols=df.columns.tolist()
    strains=cols[cols.index('QUAL')+1:cols.index('TargetCpGPos')]
    keep_cols=['Probe_ID','Type', '#CHROM', 'ID', 'REF', 'ALT','QUAL']
    df=df.loc[:,keep_cols+strains]
    df=df.set_index(keep_cols).stack().reset_index()
    df.columns=keep_cols+['Strain','Val']
    df=df.loc[df.Val==1]

    keep_cols2=['Probe_ID','#CHROM','ID', 'REF', 'ALT','QUAL','Strain']
    df=df.set_index(keep_cols2).Type.str.split('-', expand=True, n=11).reset_index()
    df.columns=keep_cols2+['Target','CpG','ExtensionBase','Context1','Context2','ProbeDesign','CON','mapFlag','RefAlt','chr','POS']
    df.Context1=df.Context1.apply(lambda x:x.upper())
    df.Context2=df.Context2.apply(lambda x:x.upper())
    df['SNPType']=df.apply(lambda x:assignType(x),axis=1)
    D = {'G1': 'Artificial low meth. reading',
         'G3': 'Artificial high meth. reading',
         'G0': 'No Effect',
         'G2': 'Suboptimal hybridization',
         'G4': 'G-R',
         'G5': 'R-G'}
    df['Group'] = df.apply(lambda x: assignGroup(x), axis=1).map(D)

    df=df.loc[:,['#CHROM','POS','ID','REF','ALT','QUAL','Probe_ID','Strain','Target','ExtensionBase','Context1',
                         'Context2','mapFlag','SNPType','Group']]
    df.to_csv(os.path.join(outdir,'strain_specific_snp.txt'),sep='\t',index=False)

def generateStrainSpecificManifest():
    manifest_dir=os.path.join(outdir,"manifests")
    if not os.path.exists(manifest_dir):
        os.mkdir(manifest_dir)
    data = pd.read_csv(os.path.join(outdir, "strain_specific_snp.txt"), sep='\t')
    mft = pd.read_csv(manifest, header=None, sep='\t',dtype={'mask': str},
                      names=['chr', 'start', 'end', 'M', 'U', 'target', 'col', 'Probe_ID', 'mapFlag', 'mask'])
    mft=mft.loc[mft['chr'].notna(),['Probe_ID','M','U','col','mask']]

    # Filter out the probes without variants or variatns without effect
    print(data.groupby('Group').Probe_ID.agg(pd.Series.nunique))
    data = data.loc[~ data.Group.isin(['No Effect'])]
    print("Generating strain-specific manifests...")
    for strain in data.Strain.unique():
        print(strain)
        masked_probes = data.query("Strain==@strain & Group!='G-R' & Group!='R-G'").Probe_ID.unique().tolist()
        red_probes = data.query("Strain==@strain & Group=='G-R'").Probe_ID.unique().tolist()
        green_probes = data.query("Strain==@strain & Group=='R-G'").Probe_ID.unique().tolist()
        mft1 = mft.copy()
        mft1.loc[mft1.Probe_ID.isin(masked_probes), 'mask'] = 'TRUE'
        if len(red_probes) > 0:
            mft1.loc[mft1.Probe_ID.isin(red_probes), 'col'] = 'R'
        if len(green_probes) > 0:
            mft1.loc[mft1.Probe_ID.isin(green_probes), 'col'] = 'G'
        mft1.to_csv(os.path.join(manifest_dir, strain + '.txt'), sep='\t', index=False)
    print("Done. Strain-specific manifests are under %s"%manifest_dir)

if __name__ == "__main__":
    print("Main")
    global vcf_has_chr, vcf_MT
    vcf_has_chr = False  # check whether the chromosome names of vcf starts with 'chr'
    vcf_MT = False  # check wiether the chromosome of mitochondria equal to MT
    mft_has_chr = False  # check whether the chromosome names of manifest starts with 'chr'
    mft_MT = False  # check wiether the chromosome of mitochondria equal to MT in manifest

    args = opt_validate(prepare_optparser())
    vcf = args.vcf
    manifest = args.mft
    Reference = args.Reference
    outdir = args.outdir
    if not os.path.exists(outdir):
        os.mkdir(outdir)

    print(vcf,manifest,outdir)
    mft_file=replace_chr_name()
    run_bedtools(mft_file, vcf)
    filter_var(vcf)
    annotate_var()
    generateStrainSpecificVariants()
    generateStrainSpecificManifest()